/**
 * Artists Routes - HTTP handlers for artist management
 * All Access Artist - Backend API v2.0.0
 */
import { Hono } from 'hono'
import { z } from 'zod'
import { ArtistsService } from '../services/artistsService.js'
import { CreateArtistSchema, IdParamSchema } from '../types/schemas.js'
import type { Bindings, Variables } from '../types/bindings.js'
import { handleServiceError } from '../utils/errorHandler.js'
import { validateRequest } from '../middleware/validation.js'
import { authErrorResponse, errorResponse } from '../utils/apiResponse.js'

const artists = new Hono<{ Bindings: Bindings; Variables: Variables }>()

const SocialMediaUpdateSchema = z.object({
  instagram_url: z.string().optional(),
  tiktok_url: z.string().optional(),
  twitter_url: z.string().optional(),
  youtube_url: z.string().optional(),
  spotify_url: z.string().optional(),
  apple_music_url: z.string().optional(),
})

// GET /api/artists - Get all artists
artists.get('/', async (c) => {
  try {
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.getAllArtists()
    return c.json({ 
      success: true, 
      data,
      meta: {
        timestamp: new Date().toISOString(),
        version: '2.0.0'
      }
    })
  } catch (error) {
    return handleServiceError(error as Error, c, 'fetch artists')
  }
})

// GET /api/artists/:id - Get artist by ID
artists.get('/:id', validateRequest('param', IdParamSchema), async (c) => {
  try {
    const { id } = c.req.valid('param')
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.getArtistById(id)
    return c.json({ success: true, data })
  } catch (error) {
    return errorResponse(
      c,
      500,
      error instanceof Error ? error.message : 'Failed to fetch artist',
      'ARTIST_FETCH_FAILED'
    )
  }
})

// POST /api/artists - Create new artist
artists.post('/', validateRequest('json', CreateArtistSchema), async (c) => {
  try {
    const validatedData = c.req.valid('json')
    
    const supabase = c.get('supabase')
    const user = c.get('user')
    const artistsService = new ArtistsService(supabase)

    if (!user?.sub) {
      return authErrorResponse(c, 'User not authenticated')
    }
    
    // Check if artist profile already exists for this user
    const { data: existingArtist } = await supabase
      .from('artist_profiles')
      .select('id, artist_name')
      .eq('user_id', user.sub)
      .maybeSingle()
    
    if (existingArtist) {
      return c.json({ 
        success: true, 
        data: existingArtist,
        meta: {
          timestamp: new Date().toISOString(),
          version: '2.0.0',
          message: 'Artist profile already exists'
        }
      }, 200)
    }
    
    // Add user_id to associate artist profile with authenticated user
    // Note: id will be auto-generated by database (gen_random_uuid())
    const artistDataWithUser = {
      ...validatedData,
      user_id: user.sub // Associate with authenticated user
    }
    
    const data = await artistsService.createArtist(artistDataWithUser)
    return c.json({ 
      success: true, 
      data,
      meta: {
        timestamp: new Date().toISOString(),
        version: '2.0.0'
      }
    }, 201)
  } catch (error) {
    return handleServiceError(error as Error, c, 'create artist')
  }
})

// PUT /api/artists/:id - Update artist
artists.put(
  '/:id',
  validateRequest('param', IdParamSchema),
  validateRequest('json', CreateArtistSchema.partial()),
  async (c) => {
  try {
    const { id } = c.req.valid('param')
    const artistData = c.req.valid('json')
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.updateArtist(id, artistData)
    return c.json({ success: true, data })
  } catch (error) {
    return errorResponse(
      c,
      500,
      error instanceof Error ? error.message : 'Failed to update artist',
      'ARTIST_UPDATE_FAILED'
    )
  }
})

// DELETE /api/artists/:id - Delete artist
artists.delete('/:id', validateRequest('param', IdParamSchema), async (c) => {
  try {
    const { id } = c.req.valid('param')
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.deleteArtist(id)
    return c.json({ success: true, data })
  } catch (error) {
    return errorResponse(
      c,
      500,
      error instanceof Error ? error.message : 'Failed to delete artist',
      'ARTIST_DELETE_FAILED'
    )
  }
})

// PATCH /api/artists/social-media - Update social media URLs for current user
artists.patch('/social-media', validateRequest('json', SocialMediaUpdateSchema), async (c) => {
  try {
    const body = c.req.valid('json')
    const supabase = c.get('supabase')
    const user = c.get('user')
    const artistsService = new ArtistsService(supabase)

    if (!user?.sub) {
      return authErrorResponse(c, 'User not authenticated')
    }
    
    // Validate social media URLs using partial schema
    const socialMediaFields = {
      instagram_url: body.instagram_url,
      tiktok_url: body.tiktok_url,
      twitter_url: body.twitter_url,
      youtube_url: body.youtube_url,
      spotify_url: body.spotify_url,
      apple_music_url: body.apple_music_url
    }
    
    // Filter out undefined values
    const updateData = Object.fromEntries(
      Object.entries(socialMediaFields).filter(([_, value]) => value !== undefined)
    )
    
    const data = await artistsService.updateSocialMediaUrls(user.sub, updateData)
    return c.json({ 
      success: true, 
      data,
      meta: {
        timestamp: new Date().toISOString(),
        version: '2.0.0'
      }
    })
  } catch (error) {
    return errorResponse(
      c,
      500,
      error instanceof Error ? error.message : 'Failed to update social media URLs',
      'ARTIST_SOCIAL_MEDIA_UPDATE_FAILED'
    )
  }
})

export default artists
