/**
 * Artists Routes - HTTP handlers for artist management
 * All Access Artist - Backend API v2.0.0
 */
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { ZodError } from 'zod'
import { ArtistsService } from '../services/artistsService.js'
import { CreateArtistSchema } from '../types/schemas.js'
import type { Bindings, Variables } from '../types/bindings.js'
import { handleValidationError, handleServiceError, handleNotFoundError, handleDatabaseError } from '../utils/errorHandler.js'

const artists = new Hono<{ Bindings: Bindings; Variables: Variables }>()

// GET /api/artists - Get all artists
artists.get('/', async (c) => {
  try {
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.getAllArtists()
    return c.json({ 
      success: true, 
      data,
      meta: {
        timestamp: new Date().toISOString(),
        version: '2.0.0'
      }
    })
  } catch (error) {
    return handleServiceError(error as Error, c, 'fetch artists')
  }
})

// GET /api/artists/:id - Get artist by ID
artists.get('/:id', async (c) => {
  try {
    const id = c.req.param('id')
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.getArtistById(id)
    return c.json({ success: true, data })
  } catch (error) {
    return c.json({ 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to fetch artist' 
    }, 500)
  }
})

// POST /api/artists - Create new artist
artists.post('/', async (c) => {
  try {
    // Manual validation with standardized error handling
    const body = await c.req.json()
    const validatedData = CreateArtistSchema.parse(body)
    
    const supabase = c.get('supabase')
    const user = c.get('user')
    const artistsService = new ArtistsService(supabase)
    
    // Check if artist profile already exists for this user
    const { data: existingArtist } = await supabase
      .from('artist_profiles')
      .select('id, artist_name')
      .eq('user_id', user.sub)
      .maybeSingle()
    
    if (existingArtist) {
      return c.json({ 
        success: true, 
        data: existingArtist,
        meta: {
          timestamp: new Date().toISOString(),
          version: '2.0.0',
          message: 'Artist profile already exists'
        }
      }, 200)
    }
    
    // Add user_id to associate artist profile with authenticated user
    // Note: id will be auto-generated by database (gen_random_uuid())
    const artistDataWithUser = {
      ...validatedData,
      user_id: user.sub // Associate with authenticated user
    }
    
    const data = await artistsService.createArtist(artistDataWithUser)
    return c.json({ 
      success: true, 
      data,
      meta: {
        timestamp: new Date().toISOString(),
        version: '2.0.0'
      }
    }, 201)
  } catch (error) {
    if (error instanceof ZodError) {
      return handleValidationError(error, c)
    }
    return handleServiceError(error as Error, c, 'create artist')
  }
})

// PUT /api/artists/:id - Update artist
artists.put('/:id', zValidator('json', CreateArtistSchema.partial()), async (c) => {
  try {
    const id = c.req.param('id')
    const artistData = c.req.valid('json')
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.updateArtist(id, artistData)
    return c.json({ success: true, data })
  } catch (error) {
    return c.json({ 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to update artist' 
    }, 500)
  }
})

// DELETE /api/artists/:id - Delete artist
artists.delete('/:id', async (c) => {
  try {
    const id = c.req.param('id')
    const supabase = c.get('supabase')
    const artistsService = new ArtistsService(supabase)
    
    const data = await artistsService.deleteArtist(id)
    return c.json({ success: true, data })
  } catch (error) {
    return c.json({ 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to delete artist' 
    }, 500)
  }
})

// PATCH /api/artists/social-media - Update social media URLs for current user
artists.patch('/social-media', async (c) => {
  try {
    const body = await c.req.json()
    const supabase = c.get('supabase')
    const user = c.get('user')
    const artistsService = new ArtistsService(supabase)
    
    // Validate social media URLs using partial schema
    const socialMediaFields = {
      instagram_url: body.instagram_url,
      tiktok_url: body.tiktok_url,
      twitter_url: body.twitter_url,
      youtube_url: body.youtube_url,
      spotify_url: body.spotify_url,
      apple_music_url: body.apple_music_url
    }
    
    // Filter out undefined values
    const updateData = Object.fromEntries(
      Object.entries(socialMediaFields).filter(([_, value]) => value !== undefined)
    )
    
    const data = await artistsService.updateSocialMediaUrls(user.sub, updateData)
    return c.json({ 
      success: true, 
      data,
      meta: {
        timestamp: new Date().toISOString(),
        version: '2.0.0'
      }
    })
  } catch (error) {
    return c.json({ 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to update social media URLs' 
    }, 500)
  }
})

export default artists
